/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 42:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var Utils = _interopRequireWildcard(__webpack_require__(925));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
/**
 * @class
  Entry
* @summary Creates an instance of `Entry`.
* @description An initializer is responsible for creating Entry object.
* @param {String} uid - uid of the entry
* @example
* let Entry = Stack.ContentType('example').Entry('entry_uid');
* @returns {Entry}
* @instance
*/
var Entry = exports["default"] = /*#__PURE__*/function () {
  function Entry() {
    _classCallCheck(this, Entry);
    this._query = {};
    /**
         * @method only
         * @memberOf Entry
         * @description Displays values of only the specified fields of entries or assets in the response
         * @param {String} [key=BASE] -  Assets: </br>
         *                                <p>Retrieves specified field of asset</p>
         * @param {String}            -  Entries:</br>
         *                                       <p>- retrieves default fields of the schema.</p>
         *                                       <p>- referenced_content-type-uid : retrieves fields of the referred content type.</p>
         * @param {Array} values - array of fields that you want to display in the response
         * @example
         * <caption> The only function with field_uid will include the data of only the specified fields for each entry and exclude the data of all other fields. </caption>
         * Stack.ContentType('contentTypeUid').Query().only('title').toJSON().find()
         * @example
         * <caption> The only function with an array of field_uids will include multiple fields for each entry and exclude the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().only(['title','description']).toJSON().find()
         * @example
         * <caption> In only, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of "reference_field_uid", and the second parameter to include the data of only the specified field_uid for each entry and exclude the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid','title').toJSON().find()
         * @example
         * <caption> In only, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of "reference_field_uid", and the second parameter with an array of fields to include the data of only the specified array of field_uids for each entry and exclude the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid', ['title', 'description']).toJSON().find()
         *
         * @returns {Entry}
         * @instance
         */
    this.only = Utils.transform('only');
    /**
         * @method except
         * @memberOf Entry
         * @description Displays all data of an entries or assets excluding the data of the specified fields.
         * @param {String} [key=BASE] - BASE (default value) - retrieves default fields of the schema.
                                                             - referenced_content-type-uid - retrieves fields of the referred content type.
         * @param {Array} values - array of fields that you want to skip in the response
         * @example
         * <caption> The except function with field_uid will exclude the data of only the specified fields for each entry and includes the data of all other fields. </caption>
         * Stack.ContentType('contentTypeUid').Query().except('title').toJSON().find()
         * @example
         * <caption> The except function with an array of field_uids will except multiple fields for each entry and include the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().except(['title','description']).toJSON().find()
         * @example
         * <caption> In except, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of "reference_field_uid", and the second parameter to except the data of only the specified field_uid for each entry and include the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid','title').toJSON().find()
         * @example
         * <caption> In except, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of "reference_field_uid", and the second parameter with an array of fields to except the data of only the specified array of field_uids for each entry and include the data of all other fields.</caption>
         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid', ['title', 'description']).toJSON().find()
         * @returns {Entry}
         * @instance
         */
    this.except = Utils.transform('except');
    return this;
  }
  return _createClass(Entry, [{
    key: "setCacheProvider",
    value: function setCacheProvider(provider) {
      if (provider && _typeof(provider) === 'object') {
        this.provider = provider;
      }
      return this;
    }
  }, {
    key: "setCachePolicy",
    value: function setCachePolicy(policy) {
      if (typeof policy === 'number' && policy >= -1 && policy < 4) {
        if (!this._query) {
          this.cachePolicy = policy;
        } else {
          this.queryCachePolicy = policy;
        }
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide the valid policy');
      }
      return this;
    }

    /**
       * @method includeReference
       * @memberOf Entry
       * @description Fetches the entire content of referenced entry(ies). <a href='https://www.contentstack.com/docs/developers/apis/content-delivery-api/#include-reference'>Read More</a>
       * @example
       * <caption> .includeReference with reference_field_uids as array </caption>
       * var Query = Stack.ContentType(contentTypes.source).Query();
              Query
                  .includeReference(['reference_field_uid', 'other_reference_field_uid'])
                  .toJSON()
                  .find()
                  .then(function success(entries) {
                      //'entries' is  an object used to retrieve data including reference entries.
                  })
       * @example
       * <caption> .includeReference with reference_field_uids and its children reference </caption>
       * var Query = Stack.ContentType(contentTypes.source).Query();
              Query
                  .includeReference(['reference_field_uid', 'reference_field_uid.child_reference_field_uid'])
                  .toJSON()
                  .find()
                  .then(function success(entries) {
                      //'entries' is  an object used to retrieve data including reference entries.
                  })
       * @example
       * <caption> .includeReference with reference_field_uids </caption>
       * var Query = Stack.ContentType(contentTypes.source).Query();
       Query
          .includeReference('reference_field_uid')
          .toJSON()
          .find()
          .then(function success(entries) {
              //'entries' is  an object used to retrieve data including particular reference using reference_uid.
          })
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeReference",
    value: function includeReference() {
      for (var _len = arguments.length, val = new Array(_len), _key = 0; _key < _len; _key++) {
        val[_key] = arguments[_key];
      }
      if (Array.isArray(val) || typeof val === 'string') {
        if (arguments.length) {
          for (var i = 0; i < arguments.length; i++) {
            this._query.include = this._query.include || [];
            this._query.include = this._query.include.concat(arguments[i]);
          }
        }
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a String or an Array.');
      }
    }

    /**
       * Sets the language code of which you want to retrieve data.
       * @param {String} language_code - language code. e.g. 'en-us', 'ja-jp', etc.
       * @memberOf Entry
       * @example
       * let data = Stack.ContentType(contentTypeUid).Entry(entryUid).language('ja-jp').fetch()
       * data
       *      .then(function(result) {
       *           // 'result' is  an object used to retrieve data of ja-jp language.
       *      }, function(error) {
       *           // error function
       *      })
       *
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "language",
    value: function language(language_code) {
      if (language_code && typeof language_code === 'string') {
        this._query.locale = language_code;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a String.');
      }
    }

    /**
       * @method addQuery
       * @memberOf Entry
       * @description Adds query to Entry object
       * @param {String} key - key of the query
       * @param {String} value - value of the query
       * @example Stack.ContentType(contentTypeUid).Entry(entry_uid).addQuery('include_schema',true)
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "addQuery",
    value: function addQuery(key, value) {
      if (key && value && typeof key === 'string') {
        this._query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'First argument should be a String.');
      }
    }

    /**
       * @method includeEmbeddedItems
       * @memberOf Entry
       * @description Include Embedded Objects (Entries and Assets) along with entry/entries details.
       * @example Stack.ContentType("contentType_uid").Entry("entry_uid").includeEmbeddedItems().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeEmbeddedItems",
    value: function includeEmbeddedItems() {
      this._query.include_embedded_items = ['BASE'];
      return this;
    }

    /**
       * @method includeSchema
       * @memberOf Entry
       * @deprecated since version 3.3.0
       * @description  Include schema of the current content type along with entry/entries details.
       * @example Stack.ContentType("contentType_uid").Entry("entry_uid").includeSchema().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeSchema",
    value: function includeSchema() {
      this._query.include_schema = true;
      return this;
    }

    /**
       * @method includeReferenceContentTypeUid
       * @memberOf Entry
       * @description  This method also includes the content type UIDs of the referenced entries returned in the response.
       * @example Stack.ContentType("contentType_uid").Entry("entry_uid").includeReferenceContentTypeUID().fetch()
       * @example
       * Query = Stack.ContentType("contentType_uid").Entry("entry_uid").includeReferenceContentTypeUID().fetch()
       * Query
       *      .toJSON()
       *      .then(function (result) {
       *          let value = result.get(field_uid)
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeReferenceContentTypeUID",
    value: function includeReferenceContentTypeUID() {
      this._query.include_reference_content_type_uid = true;
      return this;
    }

    /**
       * @method includeFallback
       * @memberOf Entry
       * @description Include the fallback locale publish content, if specified locale content is not publish.
       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeFallback",
    value: function includeFallback() {
      this._query.include_fallback = true;
      return this;
    }

    /**
       * @method includeBranch
       * @memberOf Entry
       * @description Include the Branch for publish content.
       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeBranch().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeBranch",
    value: function includeBranch() {
      this._query.include_branch = true;
      return this;
    }

    /**
       * @method includeMetadata
       * @memberOf Entry
       * @description Include the metadata for getting metadata content for the entry.
       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeMetadata().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeMetadata",
    value: function includeMetadata() {
      this._query.include_metadata = true;
      return this;
    }

    /**
       * @method includeContentType
       * @memberOf Entry
       * @description Include the details of the content type along with the entry/entries details.
       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeContentType().fetch()
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "includeContentType",
    value: function includeContentType() {
      this._query.include_content_type = true;
      return this;
    }

    /**
       * @method includeOwner
       * @memberOf Entry
       * @description Include the owner details along with the entry/entries details.
       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeOwner().fetch()
       * @returns {Entry}
       * @deprecated The includeOwner function is deprecated.
       * @instance
       */
  }, {
    key: "includeOwner",
    value: function includeOwner() {
      console.warn('The includeOwner function is deprecated.');
      this._query.include_owner = true;
      return this;
    }

    /**
       * @method toJSON
       * @memberOf Entry
       * @description Converts your response into plain JavasScript object.Supports both entry and asset queries.
       * @example
       * Query = Stack.ContentType(contentTypeUid).Entry(entryUid).fetch()
       * Query
       *      .toJSON()
       *      .then(function (result) {
       *          let value = result.get(field_uid)
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "toJSON",
    value: function toJSON() {
      this.tojson = true;
      return this;
    }

    /**
       * @method addParam
       * @memberOf Entry
       * @description Includes query parameters in your queries.
       * @example var data = Stack.ContentType(contentTypeUid).Entry(entryUid).addParam('include_count', 'true').fetch()
       *      data.then(function (result) {
       *          // 'result' is an object which content the data including count in json object form
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "addParam",
    value: function addParam(key, value) {
      if (key && value && typeof key === 'string' && typeof value === 'string') {
        this._query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method Variants
       * @memberOf Entry
       * @param {String} uid - uid of the variants entry
       * @description An initializer is responsible for creating Variants Entry object
       * @returns {Variants}
       * @instance
       */
  }, {
    key: "variants",
    value: function variants(variant_headers) {
      if (Array.isArray(variant_headers) && variant_headers.length > 0) {
        this.headers['x-cs-variant-uid'] = variant_headers.join(',');
      } else {
        this.headers['x-cs-variant-uid'] = variant_headers;
      }
      return this;
    }

    /**
       * @method fetch
       * @memberOf Entry
       * @description Fetches a particular entry based on the provided entry UID.
       * @example
       * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch()
       *
       * @example
       * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch({
       *
       *      })
       * @returns {promise}
       * @instance
       */
  }, {
    key: "fetch",
    value: function fetch(fetchOptions) {
      var host = this.config.host + ':' + this.config.port;
      if (this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {
        host = this.live_preview.host;
      }
      if (this.entry_uid) {
        this.requestParams = {
          method: 'POST',
          headers: Utils.mergeDeep({}, this.headers),
          url: this.config.protocol + '://' + host + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries + this.entry_uid,
          body: {
            _method: 'GET',
            query: this._query
          }
        };
        var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);
        return Utils.sendRequest(Utils.mergeDeep({}, this), options);
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', "Kindly provide an entry uid. e.g. .Entry('asset_uid')");
      }
    }
  }]);
}();

/***/ }),

/***/ 94:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.get = get;
exports.getKeys = getKeys;
exports.getStorage = getStorage;
exports.set = set;
var _localstorage = _interopRequireDefault(__webpack_require__(880));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function get(key) {
  var data = _localstorage["default"].getItem(key);
  try {
    data = JSON.parse(data);
  } catch (e) {
    return data;
  }
  return data || null;
}
function set(key, data) {
  try {
    if (_typeof(data) === 'object') {
      _localstorage["default"].setItem(key, JSON.stringify(data));
    } else {
      _localstorage["default"].setItem(key, data);
    }
  } catch (error) {}
}
function getStorage() {
  return _localstorage["default"] || null;
}
function getKeys() {
  return _localstorage["default"] ? Object.keys(_localstorage["default"]) : [];
}

/***/ }),

/***/ 185:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Request;
var Utils = _interopRequireWildcard(__webpack_require__(925));
var _http = _interopRequireDefault(__webpack_require__(940));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
// JS SDK version
var version = '3.26.2';
var environment, api_key;
function Request(stack, fetchOptions) {
  var requestParams = stack.requestParams;
  return new Promise(function (resolve, reject) {
    var queryParams;
    var params = new URLSearchParams();
    var _serialize = function serialize(obj, prefix) {
      if (_typeof(obj) === 'object' && obj.length !== undefined) {
        for (var i = 0, _i = obj.length; i < _i; i++) {
          params.append(prefix + '[]', obj[i]);
        }
      } else {
        for (var p in obj) {
          var k = prefix ? prefix + '[' + p + ']' : p;
          var v = obj[p];
          v !== null && _typeof(v) === 'object' && p !== 'query' ? _serialize(v, k) : params.append(k, p !== 'query' ? v : JSON.stringify(v));
        }
      }
      return params.toString();
    };

    // setting headers
    requestParams.headers['Content-Type'] = 'application/json; charset=UTF-8';
    requestParams.headers['X-User-Agent'] = 'contentstack-delivery-javascript-nodejs/' + version;
    if (requestParams.body && _typeof(requestParams.body) === 'object') {
      delete requestParams.body._method;
      if (_typeof(requestParams.body.query) === 'object' && Object.keys(requestParams.body.query).length === 0) delete requestParams.body.query;
      queryParams = _serialize(requestParams.body);
    }
    return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, fetchOptions.retryDelay, fetchOptions.retryLimit);
  });
}
function wait(retryDelay) {
  return new Promise(function (resolve) {
    setTimeout(resolve, retryDelay);
  });
}
function fetchRetry(stack, queryParams, fetchOptions, resolve, reject) {
  var retryDelay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 300;
  var retryLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 5;
  var requestParams = stack.requestParams;
  var url = requestParams.url + '?' + queryParams;
  var headers = requestParams.headers;
  var option = Utils.mergeDeep({
    method: 'GET',
    headers: headers,
    timeout: 30000
  }, fetchOptions);
  function onError(error) {
    if (retryLimit === 0) {
      if (fetchOptions.debug) fetchOptions.logHandler('error', error);
      reject(error);
    } else {
      var msDelay = retryDelay;
      retryLimit = retryLimit - 1;
      var retryCount = fetchOptions.retryLimit - retryLimit;
      if (fetchOptions.retryDelayOptions) {
        if (fetchOptions.retryDelayOptions.base) {
          msDelay = fetchOptions.retryDelayOptions.base * retryCount;
        } else if (fetchOptions.retryDelayOptions.customBackoff) {
          msDelay = fetchOptions.retryDelayOptions.customBackoff(retryCount, error);
        }
      }
      wait(msDelay).then(function () {
        return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, retryDelay, retryLimit);
      })["catch"](function () {
        return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, retryDelay, retryLimit);
      });
    }
  }
  if (fetchOptions.debug) fetchOptions.logHandler('info', {
    url: url,
    option: option
  });
  var request = {
    url: url,
    option: option
  };
  var plugins = stack.plugins;
  if (plugins && plugins !== undefined) {
    for (var index = 0; index < plugins.length; index++) {
      if (typeof plugins[index].onRequest === 'function') {
        request = plugins[index].onRequest(stack, request);
      }
    }
  }
  (0, _http["default"])(request.url, request.option).then(function (response) {
    if (fetchOptions.debug) fetchOptions.logHandler('info', response);
    var data = response.json();
    if (response.ok && response.status === 200) {
      data.then(function (json) {
        for (var _index = 0; _index < plugins.length && typeof plugins[_index].onResponse === 'function'; _index++) {
          json = plugins[_index].onResponse(stack, request, response, json);
        }
        resolve(json);
      });
    } else {
      var status = response.status,
        statusText = response.statusText;
      data.then(function (json) {
        var error_message = json.error_message,
          error_code = json.error_code,
          errors = json.errors;
        var errorDetails = {
          error_message: error_message,
          error_code: error_code,
          errors: errors,
          status: status,
          statusText: statusText
        };
        if (fetchOptions.retryCondition && fetchOptions.retryCondition(response)) {
          onError(errorDetails);
        } else {
          if (fetchOptions.debug) fetchOptions.logHandler('error', errorDetails);
          reject(errorDetails);
        }
      })["catch"](function () {
        if (fetchOptions.debug) fetchOptions.logHandler('error', {
          status: status,
          statusText: statusText
        });
        reject({
          status: status,
          statusText: statusText
        });
      });
    }
  })["catch"](function (error) {
    if (fetchOptions.debug) fetchOptions.logHandler('error', error);
    reject(error);
  });
}

/***/ }),

/***/ 209:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var Utils = _interopRequireWildcard(__webpack_require__(925));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
/**
 * @class Result
 * @summary Creates an instance of `Result`.
 * @description An initializer is responsible for creating Result object.
 * @param {Object} object - API result object
 * @example
 * blogEntry.then(function (result) {
 *      // success function
 * },function (error) {
 *      // error function
 * })
 * @example
 * assetQuery.then(function (result) {
 *      // success function
 * },function (error) {
 *      // error function
 * })
 * @returns {Result}
 * @instance
 */
var Result = exports["default"] = /*#__PURE__*/function () {
  function Result(object) {
    _classCallCheck(this, Result);
    if (object) {
      this.object = function () {
        return object;
      };
    }
    return this;
  }

  /**
     * @method toJSON
     * @memberOf Result
     * @description Converts `Result` to plain javascript object.
     * @example
     * blogEntry.then(function (result) {
     *      result = result[0][0].toJSON()
     * },function (error) {
     *      // error function
     * })
     * @example
     * assetQuery.then(function (result) {
     *      result = result[0][0].toJSON()
     * },function (error) {
     *      // error function
     * })
     * @returns {object}
     * @instance
     */
  return _createClass(Result, [{
    key: "toJSON",
    value: function toJSON() {
      return this.object() ? Utils.mergeDeep(JSON.parse(JSON.stringify({})), this.object()) : null;
    }

    /**
       * @method get
       * @memberOf Result
       * @description Retrieve details of a field based on the UID provided
       * @param field_uid uid of the field
       * @example
       * blogEntry.then(function (result) {
       *      let value = result[0][0].get(field_uid)
       * },function (error) {
       *      // error function
       * })
       * @example
       * assetQuery.then(function (result) {
       *      let value = result[0][0].get(field_uid)
       * },function (error) {
       *      // error function
       * })
       * @returns {promise}
       * @instance
       */
  }, {
    key: "get",
    value: function get(key) {
      if (this.object() && key) {
        var fields = key.split('.');
        var value = fields.reduce(function (prev, field) {
          return prev[field];
        }, this.object());
        return value;
      }
    }

    /**
       * @method getDownloadUrl
       * @memberOf Result
       * @description Retrieves the download URL based on the disposition value.
       * @param {String} string - disposition value
       * @example
       * assetQuery.then(function (result) {
       *      let value = result[0][0].getDownloadUrl(disposition_value)
       * },function (error) {
       *      // error function
       * })
       * @returns {Object}
       * @instance
       */
  }, {
    key: "getDownloadUrl",
    value: function getDownloadUrl(disposition) {
      if (this.object()) {
        var url = this.object().url ? this.object().url : null;
        var _disposition = disposition && typeof disposition === 'string' ? disposition : 'attachment';
        return url ? url + '?disposition=' + _disposition : null;
      }
    }
  }]);
}();

/***/ }),

/***/ 241:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var config = {
  protocol: "https",
  host: "cdn.contentstack.io",
  port: 443,
  version: "v3",
  urls: {
    sync: "/stacks/sync",
    content_types: "/content_types/",
    entries: "/entries/",
    assets: "/assets/",
    environments: "/environments/",
    taxonomies: "/taxonomies/entries"
  },
  live_preview: {
    enable: false,
    host: 'rest-preview.contentstack.com'
  }
};
var _default = exports["default"] = config;

/***/ }),

/***/ 253:
/***/ ((module) => {

module.exports = require("@contentstack/utils");

/***/ }),

/***/ 275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _query = _interopRequireDefault(__webpack_require__(318));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
// Overrideing compare function to include level
var _extend = {
  compare: function compare(type) {
    return function (key, value, levels) {
      if (key && value && typeof key === 'string' && typeof value !== 'undefined') {
        this._query.query[key] = this._query.query.file_size || {};
        this._query.query[key][type] = value;
        if (levels && typeof levels === 'number') {
          this._query.query[key].levels = levels;
        }
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    };
  }
};
var Taxonomy = exports["default"] = /*#__PURE__*/function (_Query) {
  function Taxonomy() {
    var _this;
    _classCallCheck(this, Taxonomy);
    _this = _callSuper(this, Taxonomy);
    /**
     * @method above
     * @memberOf Query
     * @description Get all entries for a specific taxonomy that match only the parent term(s) of a specified target term, excluding the target term itself. You can also specify a specific level.
     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`
     * @param {*} value - uid of the term to be matched
     * @example For taxonomy_uid = taxonomy1, and term_uid = term1
     * let blogQuery = Stack().ContentType('example').Query();
     *          let data = blogQuery.above("taxonomies.taxonomy1", "term1").toJSON().find() // without levels
     *          let data = blogQuery.above("taxonomies.taxonomy1", "term1", 4).toJSON().find() // with levels
     *          data.then(function (result) {
     *          // result = the data which matches only the parent term(s) of the specified term, excluding the term itself
     *       },function (error) {
     *          // error function
     *      })
     * @returns {Query}
     * @instance
     */
    _this.above = _extend.compare('$above');

    /**
     * @method equalAndAbove
     * @memberOf Query
     * @description Get all entries for a specific taxonomy that match a specific term and all its ancestor terms, requiring only the target term and a specified level.
     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`
     * @param {*} value - uid of the term to be matched
     * @example For taxonomy_uid = taxonomy1, and term_uid = term1
     * let blogQuery = Stack().ContentType('example').Query();
     *          let data = blogQuery.equalAndAbove("taxonomies.taxonomy1", "term1").toJSON().find() // without levels
     *          let data = blogQuery.equalAndAbove("taxonomies.taxonomy1", "term1", 4).toJSON().find() // with levels
     *          data.then(function (result) {
     *          // result = the data which matches a specific term and all its ancestor terms
     *       },function (error) {
     *          // error function
     *      })
     * @returns {Query}
     * @instance
     */
    _this.equalAndAbove = _extend.compare('$eq_above');

    /**
     * @method below
     * @memberOf Query
     * @description Get all entries for a specific taxonomy that match all of their descendant terms by specifying only the target term and a specific level.
     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`
     * @param {*} value - uid of the term to be matched
     * @example For taxonomy_uid = taxonomy1, and term_uid = term1
     * let blogQuery = Stack().ContentType('example').Query();
     *          let data = blogQuery.below("taxonomies.taxonomy1", "term1").toJSON().find() // without levels
     *          let data = blogQuery.below("taxonomies.taxonomy1", "term1", 4).toJSON().find() // with levels
     *          data.then(function (result) {
     *          // result = the data which matches all of the descendant terms.
     *       },function (error) {
     *          // error function
     *      })
     * @returns {Query}
     * @instance
     */
    _this.below = _extend.compare('$below');

    /**
     * @method equalAndBelow
     * @memberOf Query
     * @description Get all entries for a specific taxonomy that match a specific term and all its descendant terms, requiring only the target term and a specified level.
     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`
     * @param {*} value - uid of the term to be matched
     * @example For taxonomy_uid = taxonomy1, and term_uid = term1
     * let blogQuery = Stack().ContentType('example').Query();
     *          let data = blogQuery.equalAndBelow("taxonomies.taxonomy1", "term1").toJSON().find() // without levels
     *          let data = blogQuery.equalAndBelow("taxonomies.taxonomy1", "term1", 4).toJSON().find() // with levels
     *          data.then(function (result) {
     *          // result = the data which matches a specific term and all its descendant terms.
     *       },function (error) {
     *          // error function
     *      })
     * @returns {Query}
     * @instance
     */
    _this.equalAndBelow = _extend.compare('$eq_below');
    return _this;
  }
  _inherits(Taxonomy, _Query);
  return _createClass(Taxonomy);
}(_query["default"]);

/***/ }),

/***/ 285:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _localstorage = _interopRequireDefault(__webpack_require__(641));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
var CacheProvider = {};
CacheProvider.providers = function (provider) {
  if (provider) {
    return _localstorage["default"];
  } else {
    console.error('Kindly provide valid provider.');
  }
};
CacheProvider.policies = {
  IGNORE_CACHE: -1,
  ONLY_NETWORK: 0,
  CACHE_ELSE_NETWORK: 1,
  NETWORK_ELSE_CACHE: 2,
  CACHE_THEN_NETWORK: 3
};
var _default = exports["default"] = CacheProvider;

/***/ }),

/***/ 318:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var Utils = _interopRequireWildcard(__webpack_require__(925));
var _entry = _interopRequireDefault(__webpack_require__(42));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
var _extend = {
  compare: function compare(type) {
    return function (key, value) {
      if (key && value && typeof key === 'string' && typeof value !== 'undefined') {
        this._query.query[key] = this._query.query.file_size || {};
        this._query.query[key][type] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    };
  },
  contained: function contained(bool) {
    var type = bool ? '$in' : '$nin';
    return function (key, value) {
      if (key && value && typeof key === 'string' && Array.isArray(value)) {
        this._query.query[key] = this._query.query[key] || {};
        this._query.query[key][type] = this._query.query[key][type] || [];
        this._query.query[key][type] = this._query.query[key][type].concat(value);
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    };
  },
  exists: function exists(bool) {
    return function (key) {
      if (key && typeof key === 'string') {
        this._query.query[key] = this._query.query[key] || {};
        this._query.query[key].$exists = bool;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    };
  },
  logical: function logical(type) {
    return function () {
      var _query = [];
      for (var i = 0, _i = arguments.length; i < _i; i++) {
        if (arguments[i] instanceof Query && arguments[i]._query.query) {
          _query.push(arguments[i]._query.query);
        } else if (_typeof(arguments[i]) === 'object') {
          _query.push(arguments[i]);
        }
      }
      if (this._query.query[type]) {
        this._query.query[type] = this._query.query[type].concat(_query);
      } else {
        this._query.query[type] = _query;
      }
      return this;
    };
  },
  sort: function sort(type) {
    return function (key) {
      if (key && typeof key === 'string') {
        this._query[type] = key;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a string.');
      }
    };
  },
  pagination: function pagination(type) {
    return function (value) {
      if (typeof value === 'number') {
        this._query[type] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a number.');
      }
    };
  }
};

/**
 * @function getRequestUrl
 * @description Returns host url based on this.type
 * @param  {Object} this `this` variable from Query class
 * @return {string} returns the url that will be used to make API calls
 */
function getRequestUrl(type, config, content_type_uid, baseURL) {
  var url;
  switch (type) {
    case 'asset':
      url = baseURL + config.urls.assets;
      break;
    case 'taxonomy':
      url = baseURL + config.urls.taxonomies;
      break;
    case 'contentType':
    default:
      url = baseURL + config.urls.content_types + content_type_uid + config.urls.entries;
      break;
  }
  return url;
}

/**
 * @class
   Query
 * @description
 * An initializer is responsible for creating Query object.Provides support for all search queries
 * @example
 * <caption>Query instance creation.</caption>
 * let Query = Contentstack.Stack().ContentType('example').Query();
 * let assetQuery =  Contentstack.Stack().Assets().Query();
 * @returns {Query}
 */
var Query = exports["default"] = /*#__PURE__*/function (_Entry) {
  function Query() {
    var _this;
    _classCallCheck(this, Query);
    _this = _callSuper(this, Query);
    _this._query = _this._query || {};
    _this._query.query = _this._query.query || {};
    /**
         * @method lessThan
         * @memberOf Query
         * @description Retrieves entries in which the value of a field is lesser than the provided value
         * @param {String} key - uid of the field
         * @param {*} value - Value used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.lessThan('created_at','2015-06-22').find()
         *          data.then(function (result) {
         *          // result content the data who's 'created_at date' is less than '2015-06-22'
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.lessThan = _extend.compare('$lt');

    /**
         * @method lessThanOrEqualTo
         * @memberOf Query
         * @description Retrieves entries in which the value of a field is lesser than or equal to the provided value.
         * @param {String} key - uid of the field
         * @param {*} value - Value used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.lessThanOrEqualTo('created_at','2015-06-22').find()
         *          data.then(function (result) {
         *          // result contain the data of entries where the 'created_at' date will be less than or equalto '2015-06-22'.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.lessThanOrEqualTo = _extend.compare('$lte');
    /**
         * @method greaterThan
         * @memberOf Query
         * @description Retrieves entries in which the value for a field is greater than the provided value.
         * @param {String} key - uid of the field
         * @param {*} value -  value used to match or compare
         * @example
         *          let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.greaterThan('created_at','2015-03-12').find()
         *                     data.then(function(result) {
         *                       // result contains the data of entries where the 'created_at' date will be greaterthan '2015-06-22'
         *                     },function (error) {
         *                       // error function
         *                     })
         * @returns {Query}
         * @instance
         */
    _this.greaterThan = _extend.compare('$gt');

    /**
         * @method greaterThanOrEqualTo
         * @memberOf Query
         * @description Retrieves entries in which the value for a field is greater than or equal to the provided value.
         * @param {String} key - uid of the field
         * @param {*} value - Value used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.greaterThanOrEqualTo('created_at','2015-03-12').find()
         *          data.then(function(result) {
         *          // result contains the data of entries where the 'created_at' date will be greaterThan or equalto '2015-06-22'
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.greaterThanOrEqualTo = _extend.compare('$gte');

    /**
         * @method notEqualTo
         * @memberOf Query
         * @description Retrieves entries in which the value for a field does not match the provided value.
         * @param {String} key - uid of the field
         * @param {*} value - Value used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.notEqualTo('title','Demo').find()
         *          data.then(function(result) {
         *            // result contains the list of entries where value of the title field will not be 'Demo'.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.notEqualTo = _extend.compare('$ne');

    /**
         * @method containedIn
         * @memberOf Query
         * @description Retrieve entries in which the value of a field matches with any of the provided array of values
         * @param {String} key - uid of the field
         * @param {*} value - Array of values that are to be used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.containedIn('title', ['Demo', 'Welcome']).find()
         *          data.then(function(result) {
         *          // result contains the list of entries where value of the title field will contain either 'Demo' or Welcome.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.containedIn = _extend.contained(true);

    /**
         * @method notContainedIn
         * @memberOf Query
         * @description Retrieve entries in which the value of a field does not match with any of the provided array of values.
         * @param {String} key - uid of the field
         * @param {Array} value - Array of values that are to be used to match or compare
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.notContainedIn('title', ['Demo', 'Welcome']).find()
         *          data.then(function(result) {
         *          // 'result' contains the list of entries where value of the title field should not be either "Demo" or Welcome
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.notContainedIn = _extend.contained(false);

    /**
         * @method exists
         * @memberOf Query
         * @description Retrieve entries if value of the field, mentioned in the condition, exists.
         * @param {String} key - uid of the field
         * @example blogQuery.exists('featured')
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.exists('featured').find()
         *          data.then(function(result) {
         *          // result contains the list of entries in which "featured" exists.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.exists = _extend.exists(true);

    /**
         * @method notExists
         * @memberOf Query
         * @description Retrieve entries if value of the field, mentioned in the condition, does not exists.
         * @param {String} key - uid of the field
         * @example blogQuery.notExists('featured')
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.notExists('featured').find()
         *          data.then(function(result) {
         *        // result is the list of non-existingfeatured" data.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.notExists = _extend.exists(false);

    /**
         * @method ascending
         * @memberOf Query
         * @description Sort fetched entries in the ascending order with respect to a specific field.
         * @param {String} key - field uid based on which the ordering will be done
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.ascending('created_at').find()
         *          data.then(function(result) {
         *           // result contains the list of entries which is sorted in ascending order on the basis of created_at.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.ascending = _extend.sort('asc');

    /**
         * @method descending
         * @memberOf Query
         * @description Sort fetched entries in the descending order with respect to a specific field
         * @param {String} key - field uid based on which the ordering will be done.
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.descending('created_at').find()
         *          data.then(function(result) {
         *           // result contains the list of entries which is sorted in descending order on the basis of created_at.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.descending = _extend.sort('desc');

    /**
         * @method beforeUid
         * @memberOf Query
         * @description Sort fetched entries in the descending order with respect to a specific field
         * @param {String} uid - field uid based on which the ordering will be done.
         * @example blogQuery.beforeUid('uid')
         * @returns {Query}
         * @instance
         */
    _this.beforeUid = _extend.sort('before_uid');

    /**
         * @method afterUid
         * @memberOf Query
         * @description This method provides only the entries after the specified entry id.
         * @param {String} uid - uid of the entry
         * @example blogQuery.afterUid('uid')
         * @returns {Query}
         * @instance
         */
    _this.afterUid = _extend.sort('after_uid');

    /**
         * @method skip
         * @memberOf Query
         * @description Skips at specific number of entries.
         * @param {Number} skip - number of entries to be skipped
         * @example blogQuery.skip(5)
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.skip(5).find()
         *          data.then(function(result) {
         *          // result contains the list of data which is sorted in descending order on 'created_at' bases.
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.skip = _extend.pagination('skip');

    /**
         * @method limit
         * @memberOf Query
         * @description Returns a specific number of entries based on the set limit
         * @param {Number} limit - maximum number of entries to be returned
         * @example let blogQuery = Stack().ContentType('example').Query();
         *          let data = blogQuery.limit(10).find()
         *          data.then(function(result) {
         *          // result contains the limited number of entries
         *       },function (error) {
         *          // error function
         *      })
         * @returns {Query}
         * @instance
         */
    _this.limit = _extend.pagination('limit');

    /**
         * @method or
         * @memberOf Query
         * @description Retrieves entries that satisfy at least one of the given conditions
         * @param {object} queries - array of Query objects or raw queries
         * @example
         * <caption> .or with Query instances</caption>
         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').find()
         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).find()
         * blogQuery.or(Query1, Query2)
         * @example
         * <caption> .or with raw queries</caption>
         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()
         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()
         * blogQuery.or(Query1, Query2)
         * @returns {Query}
         * @instance
         */
    _this.or = _extend.logical('$or');

    /**
         * @method and
         * @memberOf Query
         * @description Retrieve entries that satisfy all the provided conditions.
         * @param {object} queries - array of query objects or raw queries.
         * @example
         * <caption> .and with Query instances</caption>
         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo')
         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10)
         * blogQuery.and(Query1, Query2)
         * @example
         * <caption> .and with raw queries</caption>
         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()
         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()
         * blogQuery.and(Query1, Query2)
         * @returns {Query}
         * @instance
         */
    _this.and = _extend.logical('$and');
    return _this;
  }
  _inherits(Query, _Entry);
  return _createClass(Query, [{
    key: "equalTo",
    value: function equalTo(key, value) {
      if (key && typeof key === 'string') {
        this._query.query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method where
       * @memberOf Query
       * @description Retrieve entries in which a specific field satisfies the value provided
       * @param {String} key - uid of the field
       * @param {*} value - value used to match or compare
       * @example let blogQuery = Stack().ContentType('example').Query();
       *          let data = blogQuery.where('title','Demo').find()
       *          data.then(function(result) {
       *            // result contains the list of entries where value of title is equal to Demo.
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "where",
    value: function where(key, value) {
      if (key && typeof key === 'string') {
        this._query.query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method count
       * @memberOf Query
       * @description Returns the total number of entries
       * @example blogQuery.count()
       * @example let blogQuery = Stack().ContentType('example').Query();
       *          let data = blogQuery.count().find()
       *          data.then(function(result) {
       *           // result contains the total count.
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "count",
    value: function count() {
      var host = this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version;
      var url = getRequestUrl(this.type, this.config, this.content_type_uid, host);
      this._query.count = true;
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: url,
        body: {
          _method: 'GET',
          query: this._query
        }
      };
      return this;
    }

    /**
       * @method query
       * @memberOf Query
       * @description Retrieve entries based on raw queries
       * @param {object} query - RAW (JSON) queries
       * @returns {Query}
       * @instance
       * @example
       * let blogQuery = Stack().ContentType('example').Query();
       * let data = blogQuery.query({"brand": {"$nin_query": {"title": "Apple Inc."}}}).find()
       * data.then(function(result) {
       *    // result contains the total count.
       * },function (error) {
       *    // error function
       * })
       */
  }, {
    key: "query",
    value: function query(_query2) {
      if (_typeof(_query2) === 'object') {
        this._query.query = Utils.mergeDeep(this._query.query, _query2);
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters');
      }
    }

    /**
       * @method referenceIn
       * @memberOf Query
       * @description Retrieve entries that satisfy the query conditions made on referenced fields.
       * @param {Query} query - RAW (JSON) queries
       * @returns {Query}
       * @instance
       * @example
       * <caption> referenceIn with Query instances</caption>
       * let blogQuery = Stack().ContentType('example').Query();
       * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')
       * let data = blogQuery.referenceIn("brand", Query).find()
       * data.then(function(result) {
       *    // result contains the total count.
       * },function (error) {
       *    // error function
       * })
       *
       * @example
       * <caption> referenceIn with raw queries</caption>
       * let blogQuery = Stack().ContentType('example').Query();
       * let data = blogQuery.referenceIn("brand", {'title': 'Demo'}).find()
       * data.then(function(result) {
       *    // result contains the total count.
       * },function (error) {
       *    // error function
       * })
       */
  }, {
    key: "referenceIn",
    value: function referenceIn(key, query) {
      var _query = {};
      if (query instanceof Query && query._query.query) {
        _query.$in_query = query._query.query;
      } else if (_typeof(query) === 'object') {
        _query.$in_query = query;
      }
      if (this._query.query[key]) {
        this._query.query[key] = this._query.query[key].concat(_query);
      } else {
        this._query.query[key] = _query;
      }
      return this;
    }

    /**
       * @method referenceNotIn
       * @memberOf Query
       * @description Retrieve entries that does not satisfy the query conditions made on referenced fields.
       * @param {Query} query - RAW (JSON) queries
       * @returns {Query}
       * @instance
       * @example
       * <caption> referenceNotIn with Query instances</caption>
       * let blogQuery = Stack().ContentType('example').Query();
       * let data = blogQuery.referenceNotIn("brand", {'title': 'Demo'}).find()
       * data.then(function(result) {
       *    // result contains the total count.
       * },function (error) {
       *    // error function
       * })
       *
       * @example
       * <caption> referenceNotIn with raw queries</caption>
       * let blogQuery = Stack().ContentType('example').Query();
       * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')
       * let data = blogQuery.referenceNotIn("brand", Query).find()
       * data.then(function(result) {
       *    // result contains the total count.
       * },function (error) {
       *    // error function
       * })
       */
  }, {
    key: "referenceNotIn",
    value: function referenceNotIn(key, query) {
      var _query = {};
      if (query instanceof Query && query._query.query) {
        _query.$nin_query = query._query.query;
      } else if (_typeof(query) === 'object') {
        _query.$nin_query = query;
      }
      if (this._query.query[key]) {
        this._query.query[key] = this._query.query[key].concat(_query);
      } else {
        this._query.query[key] = _query;
      }
      return this;
    }

    /**
       * @method tags
       * @memberOf Query
       * @description Retrieves entries based on the provided tags
       * @param {Array} values - tags
       * @example let blogQuery = Stack().ContentType('example').Query();
       *          let data = blogQuery.tags(['technology', 'business']).find()
       *          data.then(function(result) {
       *        // result contains list of entries which have tags "technology" and "business".
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "tags",
    value: function tags(values) {
      if (Array.isArray(values)) {
        this._query.tags = values;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters');
      }
    }

    /**
       * @method includeReferenceContentTypeUid
       * @memberOf Query
       * @description  This method also includes the content type UIDs of the referenced entries returned in the response.
       * @example Stack.ContentType("contentType_uid").Query().includeReferenceContentTypeUID().find()
       * @example
       * let blogQuery = Stack.ContentType("contentType_uid").Query();
       *          let data = blogQuery.includeReferenceContentTypeUID().find()
       *          data.then(function(result) {
       *         // result contains a list of entries in which content type UIDs is present.
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "includeReferenceContentTypeUID",
    value: function includeReferenceContentTypeUID() {
      this._query.include_reference_content_type_uid = true;
      return this;
    }

    /**
       * @method includeCount
       * @memberOf Query
       * @description Includes the total number of entries returned in the response.
       * @example blogQuery.includeCount()
       * @example let blogQuery = Stack().ContentType('example').Query();
       *          let data = blogQuery.includeCount().find()
       *          data.then(function(result) {
       *         // result contains a list of entries in which count of object is present at array[1] position.
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "includeCount",
    value: function includeCount() {
      this._query.include_count = true;
      return this;
    }

    /**
       * @method addParam
       * @description Includes query parameters in your queries.
       * @memberOf Query
       * @example var data = blogQuery.addParam('include_count', 'true').fetch()
       *      data.then(function (result) {
       *          // 'result' is an object which content the data including count in json object form
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "addParam",
    value: function addParam(key, value) {
      if (key && value && typeof key === 'string' && typeof value === 'string') {
        this._query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method getQuery
       * @memberOf Query
       * @description Returns the raw (JSON) query based on the filters applied on Query object.
       * @example Stack.ContentType('contentType_uid').Query().where('title','Demo').getQuery().find()
       * @returns {Query}
       * @instance
       */
  }, {
    key: "getQuery",
    value: function getQuery() {
      return this._query.query || {};
    }

    /**
       * @method regex
       * @memberOf Query
       * @description Retrieve entries that match the provided regular expressions
       * @param {String} key - uid of the field
       * @param {*} value - value used to match or compare
       * @param {String} [options] - match or compare value in entry
       * @example
       * <caption> .regex without options</caption>
       * blogQuery.regex('title','^Demo')
       * @example
       * <caption> .regex with options</caption>
       * blogQuery.regex('title','^Demo', 'i')
       * @returns {Query}
       * @instance
       */
  }, {
    key: "regex",
    value: function regex(key, value, options) {
      if (key && value && typeof key === 'string' && typeof value === 'string') {
        this._query.query[key] = {
          $regex: value
        };
        if (options) this._query.query[key].$options = options;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method search
       * @memberOf Query
       * @deprecated since version 3.15.0
       * @description Retrieve entries that have fields which match the provided search value.
       * @param {string} value - value to search in entries
       * @example blogQuery.search('Welcome to demo')
       * @example let blogQuery = Stack().ContentType('example').Query();
       *          let data = blogQuery.search('welcome to demo').find()
       *          data.then(function(result) {
       *         // result contains the object that possess the text "welcome to demo".
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Query}
       * @instance
       */
  }, {
    key: "search",
    value: function search(value) {
      if (value && typeof value === 'string') {
        this._query.typeahead = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');
      }
    }

    /**
       * @method find
       * @memberOf Query
       * @description Retrieves entries that satisfied the specified query
       * @example let blogQuery = Stack().ContentType('example').Query().find();
       *          blogQuery.then(function(result) {
       *          // result contains the list of object.
       *       },function (error) {
       *          // error function
       *      })
       * blogQuery.find()
       * @example
       * let blogQuery = Stack.ContentType(contentTypeUid).Query().find({
       *
       *      });
       * blogQuery.then(function(result) {
       *          // result contains the list of object.
       *       },function (error) {
       *          // error function
       *      })
       * blogQuery.find()
       * @returns {promise}
       * @instance
       */
  }, {
    key: "find",
    value: function find(fetchOptions) {
      var host = this.config.host + ':' + this.config.port;
      if (this.type && this.type !== 'asset' && this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {
        host = this.live_preview.host;
      }
      var baseURL = this.config.protocol + '://' + host + '/' + this.config.version;
      var url = getRequestUrl(this.type, this.config, this.content_type_uid, baseURL);
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: url,
        body: {
          _method: 'GET',
          query: this._query
        }
      };
      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);
      return Utils.sendRequest(Utils.mergeDeep({}, this), options);
    }

    /**
       * @method Variants
       * @memberOf Query
       * @param {String} uid - uid of the variants entry
       * @description An initializer is responsible for creating Variants Entry object
       * @returns {Variants}
       * @instance
       */
  }, {
    key: "variants",
    value: function variants(variant_headers) {
      if (Array.isArray(variant_headers) && variant_headers.length > 0) {
        this.headers['x-cs-variant-uid'] = variant_headers.join(',');
      } else {
        this.headers['x-cs-variant-uid'] = variant_headers;
      }
      return this;
    }

    /**
       * @method findOne
       * @memberOf Query
       * @deprecated since version 3.3.0
       * @description Retrieve a single entry from the result
       * @example let blogQuery = Stack().ContentType('example').Query().findOne();
       *          blogQuery.then(function(result) {
       *          // result contains the single item object.
       *       },function (error) {
       *          // error function
       *      })
       * blogQuery.findOne()
       * @returns {promise}
       * @instance
       */
  }, {
    key: "findOne",
    value: function findOne() {
      var host = this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version;
      if (this.type && this.type !== 'asset' && this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {
        host = this.config.protocol + '://' + this.live_preview.host + '/' + this.config.version;
      }
      var url = getRequestUrl(this.type, this.config, this.content_type_uid, host);
      this.singleEntry = true;
      this._query.limit = 1;
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: url,
        body: {
          _method: 'GET',
          query: this._query
        }
      };
      var options = Utils.mergeDeep({}, this.fetchOptions);
      return Utils.sendRequest(Utils.mergeDeep({}, this), options)["catch"](function (error) {
        // Add HTTP status code to the error object if it exists
        if (error.status) {
          return Promise.reject(_objectSpread(_objectSpread({}, error), {}, {
            http_code: error.status,
            // Adding the HTTP status code explicitly
            http_message: error.statusText || 'An error occurred'
          }));
        }
        return Promise.reject(error); // Fallback for other errors
      });
    }
  }]);
}(_entry["default"]);

/***/ }),

/***/ 348:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(241));
var Utils = _interopRequireWildcard(__webpack_require__(925));
var _entry = _interopRequireDefault(__webpack_require__(42));
var _assets = _interopRequireDefault(__webpack_require__(537));
var _query = _interopRequireDefault(__webpack_require__(318));
var _taxonomy = _interopRequireDefault(__webpack_require__(275));
var _request = _interopRequireDefault(__webpack_require__(185));
var _index = _interopRequireDefault(__webpack_require__(285));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var errorRetry = [408, 429];

/**
     * @class
        Stack
     * @description Initialize an instance of Stack
     * @param param - Stack configuration.
     * @param param.api_key - Stack API Key.
     * @param param.delivery_token - Stack Delivery token.
     * @param param.environment - Stack Environment name.
     * @param param.region - DB region for Stack.
     * @param param.branch - Name of the branch you want to fetch data from
     * @param param.live_preview - Live preview configuration.
     * @param param.plugins - List of plugins objects.
     * @param param.fetchOptions - Custom setting for the request.
     * @param param.fetchOptions.debug - This will enable debug log. Default is false
     * @param param.fetchOptions.timeout - Set timeout for the request.
     * @param param.fetchOptions.retryLimit - The number of retries before failure. Default is 5
     * @param param.fetchOptions.retryDelay - The number of ms to use for operation retries. Default is 300ms
     * @param param.fetchOptions.retryCondition - A function to determine if the error can be retried. Default retry is on status codes 408, 429.
     * @param param.fetchOptions.retryDelayOptions.base - The base number of milliseconds to use in the exponential backoff for operation retries.
     * @param param.fetchOptions.retryDelayOptions.customBackoff - A custom function that accepts a retry count and error and returns the amount of time to delay in milliseconds.
     * @param param.fetchOptions.logHandler - A function for logging of requests, responses and errors
     *
     * @example
     * var Stack = Contentstack.Stack({
     *      'api_key':'api_key',
     *      'delivery_token':'delivery_token',
     *      'environment':'environment_name',
     *      'region': 'us',
     *      'fetchOptions': {
     *
     *      }
     * });
     *
     * @returns {Stack}
     * @instance
     */
var Stack = exports["default"] = /*#__PURE__*/function () {
  function Stack() {
    var _this = this;
    _classCallCheck(this, Stack);
    this.fetchOptions = {
      retryLimit: 5,
      retryCondition: function retryCondition(error) {
        if (errorRetry.includes(error.status)) {
          return true;
        }
        return false;
      },
      debug: false,
      logHandler: function logHandler(level, data) {
        if (level === 'error' && data) {
          console.error("[error] ".concat(data));
        } else if (level === 'warning' && data) {
          console.warn("[warning] ".concat(data));
        } else if (level === 'info' && data) {
          console.info("[info] ".concat(data));
        }
      }
    };
    this.config = JSON.parse(JSON.stringify(_config["default"]));
    this.plugins = [];
    for (var _len = arguments.length, stack_arguments = new Array(_len), _key = 0; _key < _len; _key++) {
      stack_arguments[_key] = arguments[_key];
    }
    if (stack_arguments[0].live_preview && stack_arguments[0].live_preview.enable === true && stack_arguments[0].live_preview.management_token !== null) {
      if (stack_arguments[0].live_preview.management_token) {
        this.config.live_preview.host = 'api.contentstack.io';
      }
    }
    if (stack_arguments[0].region && stack_arguments[0].region !== undefined && stack_arguments[0].region !== 'us') {
      this.config.host = stack_arguments[0].region + '-' + 'cdn.contentstack.com';
      if (stack_arguments[0].live_preview && stack_arguments[0].live_preview.enable === true) {
        if (stack_arguments[0].live_preview.management_token) {
          this.config.live_preview.host = stack_arguments[0].region + '-' + 'api.contentstack.com';
        } else {
          this.config.live_preview.host = stack_arguments[0].region + '-' + 'rest-preview.contentstack.com';
        }
      }
    }
    if (stack_arguments[0].fetchOptions && stack_arguments[0].fetchOptions !== undefined) {
      this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[0].fetchOptions);
    }
    if (stack_arguments[0].plugins && stack_arguments[0].plugins !== undefined) {
      stack_arguments[0].plugins.forEach(function (pluginObj) {
        _this.plugins.push(pluginObj);
      });
    }
    this.cachePolicy = _index["default"].policies.IGNORE_CACHE;
    this.provider = _index["default"].providers('localstorage');
    switch (stack_arguments.length) {
      case 1:
        if (_typeof(stack_arguments[0]) === 'object' && typeof stack_arguments[0].api_key === 'string' && typeof stack_arguments[0].delivery_token === 'string' && typeof stack_arguments[0].environment === 'string') {
          this.headers = {
            api_key: stack_arguments[0].api_key,
            access_token: stack_arguments[0].delivery_token
          };
          if (_typeof(stack_arguments[0].live_preview) === 'object') {
            this.live_preview = Utils.mergeDeep(this.config.live_preview, stack_arguments[0].live_preview);
            this.setLivePreviewTimelinePreviewForClient();
          }
          if (typeof stack_arguments[0].branch === 'string' && stack_arguments[0].branch !== undefined) {
            this.headers.branch = stack_arguments[0].branch;
          }
          if (_typeof(stack_arguments[0].early_access) === 'object' && Array.isArray(stack_arguments[0].early_access) && stack_arguments[0].early_access.length > 0) {
            this.headers['x-header-ea'] = stack_arguments[0].early_access.join(',');
          }
          this.environment = stack_arguments[0].environment;
          return this;
        } else {
          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid object parameters. The specified API Key, Delivery Token, or Environment Name is invalid.');
        }
      case 3:
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!");
        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {
          this.headers = {
            api_key: stack_arguments[0],
            access_token: stack_arguments[1]
          };
          this.environment = stack_arguments[2];
          return this;
        } else {
          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid string parameters.');
        }
      case 4:
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!");
        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {
          this.headers = {
            api_key: stack_arguments[0],
            access_token: stack_arguments[1]
          };
          this.environment = stack_arguments[2];
        } else {
          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid string parameters.');
        }
        if (stack_arguments[3]) {
          if (typeof stack_arguments[3] === 'string' && stack_arguments[3] !== undefined && stack_arguments[3] !== 'us') {
            this.config.host = stack_arguments[3] + '-' + 'cdn.contentstack.com';
          } else if (_typeof(stack_arguments[3]) === 'object') {
            this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[3]);
          }
        }
        return this;
      case 5:
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', "WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!");
        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {
          this.headers = {
            api_key: stack_arguments[0],
            access_token: stack_arguments[1]
          };
          this.environment = stack_arguments[2];
        } else {
          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid string parameters.');
        }
        if (stack_arguments[3]) {
          if (typeof stack_arguments[3] === 'string' && stack_arguments[3] !== undefined && stack_arguments[3] !== 'us') {
            this.config.host = stack_arguments[3] + '-' + 'cdn.contentstack.com';
          } else if (_typeof(stack_arguments[3]) === 'object') {
            this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[3]);
          }
        }
        if (stack_arguments[4] && _typeof(stack_arguments[4]) === 'object') {
          this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[4]);
        }
        return this;
      default:
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters to initialize the Contentstack javascript-SDK Stack.');
    }
  }

  /**
     * @method setPort
     * @memberOf Stack
     * @description Sets the port of the host
     * @param {Number} port - Port Number
     * @return {Stack}
     * @instance
     * */
  return _createClass(Stack, [{
    key: "setPort",
    value: function setPort(port) {
      if (typeof port === 'number') this.config.port = port;
      return this;
    }

    /**
       * @method setProtocol
       * @memberOf Stack
       * @description Sets the protocol for the host
       * @param {String} protocol - http/https protocol
       * @return {Stack}
       * @instance
       * */
  }, {
    key: "setProtocol",
    value: function setProtocol(protocol) {
      if (typeof protocol === 'string' && ~['https', 'http'].indexOf(protocol)) this.config.protocol = protocol;
      return this;
    }

    /**
       * @method setHost
       * @memberOf Stack
       * @description Sets the host of the API server
       * @param {String} host - valid ip or host
       * @return {Stack}
       * @instance
       * */
  }, {
    key: "setHost",
    value: function setHost(host) {
      if (typeof host === 'string' && host) this.config.host = host;
      return this;
    }

    /**
       * @method setCachePolicy
       * @memberOf Stack
       * @description Allows you to set cache policies
       * @param {Constant} [key=ONLY_NETWORK] - Cache policy to be applied on Stack or Query.
       * @example
       * Stack.setCachePolicy(Contentstack.CachePolicy.IGNORE_CACHE)
       * Stack.setCachePolicy(Contentstack.CachePolicy.ONLY_NETWORK)
       * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_ELSE_NETWORK)
       * Stack.setCachePolicy(Contentstack.CachePolicy.NETWORK_ELSE_CACHE)
       * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_THEN_NETWORK)
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "setCachePolicy",
    value: function setCachePolicy(policy) {
      if (typeof policy === 'number' && policy >= -1 && policy < 4) {
        if (!this._query) {
          this.cachePolicy = policy;
        } else {
          this.queryCachePolicy = policy;
        }
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide the valid policy');
      }
      return this;
    }
  }, {
    key: "setLivePreviewTimelinePreviewForClient",
    value: function setLivePreviewTimelinePreviewForClient() {
      if (Utils.isBrowser()) {
        var params = new URL(document.location.toString()).searchParams;
        if (params.has('live_preview')) {
          this.live_preview.live_preview = params.get('live_preview');
        }
        if (params.has('release_id')) {
          this.headers.release_id = params.get('release_id');
        } else {
          delete this.headers.release_id;
        }
        if (params.has('preview_timestamp')) {
          this.headers.preview_timestamp = params.get('preview_timestamp');
        } else {
          delete this.headers.preview_timestamp;
        }
      }
    }
  }, {
    key: "livePreviewQuery",
    value: function livePreviewQuery(query) {
      if (this.live_preview) {
        this.live_preview.live_preview = query.live_preview || 'init';
        this.live_preview.content_type_uid = query.content_type_uid;
        this.live_preview.entry_uid = query.entry_uid;
      }
      if (query.hasOwnProperty('release_id')) {
        this.headers.release_id = query.release_id;
      } else {
        delete this.headers.release_id;
      }
      if (query.hasOwnProperty('preview_timestamp')) {
        this.headers.preview_timestamp = query.preview_timestamp;
      } else {
        delete this.headers.preview_timestamp;
      }
    }

    /**
       * @method setCacheProvider
       * @memberOf Stack
       * @description Allows you to set an object of the cache provider
       * @example
       * Stack
       *      .setCacheProvider({
       *          get: function (key, callback) {
       *              // custom logic
       *          },
       *          set: function (key, value, callback) {
       *              // custom logic
       *          }
       *      });
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "setCacheProvider",
    value: function setCacheProvider(provider) {
      if (provider && _typeof(provider) === 'object') {
        this.provider = provider;
      }
      return this;
    }

    /**
       * @method clearByQuery
       * @memberOf Stack
       * @description 'clearByQuery' function to clear the query from the cache.
       * @example
       * Stack.clearQuery(query, callback);
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "clearByQuery",
    value: function clearByQuery() {
      if (this.provider && typeof this.provider.clearByQuery === 'function') {
        return this.provider.clearByQuery.apply(this.provider, arguments);
      }
    }

    /**
       * @method clearByContentType
       * @memberOf Stack
       * @description 'clearByContentType' function to clear the query from the cache by specified content type.
       * @example
       * Stack.clearByContentType(content_type_uid, callback);
       * Stack.clearByContentType(content_type_uid, language_uid, callback);
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "clearByContentType",
    value: function clearByContentType() {
      if (this.provider && typeof this.provider.clearByContentType === 'function') {
        return this.provider.clearByContentType.apply(this.provider, arguments);
      }
    }

    /**
       * @method clearAll
       * @memberOf Stack
       * @description 'clearAll' function to clear all the queries from cache.
       * @example
       * Stack.clearAll(callback);
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "clearAll",
    value: function clearAll() {
      if (this.provider && typeof this.provider.clearAll === 'function') {
        return this.provider.clearAll.apply(this.provider, arguments);
      }
    }

    /**
       * @method getCacheProvider
       * @memberOf Stack
       * @description Returns the currently set object of 'CacheProvider'
       * @example Stack.getCacheProvider();
       * @returns {object}
       * @instance
       */
  }, {
    key: "getCacheProvider",
    value: function getCacheProvider() {
      return this.provider;
    }

    /**
       * @method ContentType
       * @memberOf Stack
       * @description Set the content type of which you want to retrieve the entries
       * @param {String} [content_type_uid] - uid of the existing content type
       * @example
       * let data = Stack.ContentType('blog').Query().toJSON().find()
       *      data
       *      .then(function(result) {
       *           // 'result' content the list of entries of particular content type blog.
       *      }, function(error) {
       *           // error function
       *      })
       * @returns {Stack}
       * @instance
       */
  }, {
    key: "ContentType",
    value: function ContentType(uid) {
      if (uid && typeof uid === 'string') {
        this.content_type_uid = uid;
        this.type = 'contentType';
      }
      return this;
    }

    /**
       * @method Taxonomies
       * @memberof Stack
       * @description A method to set base url to taxonomies endpoint
       * @returns {Stack}
       */
  }, {
    key: "Taxonomies",
    value: function Taxonomies() {
      this.type = 'taxonomy';
      return Utils.merge(new _taxonomy["default"](), this);
    }

    /**
       * @method Entry
       * @memberOf ContentType
       * @param {String} uid - uid of the entry
       * @description An initializer is responsible for creating Entry object
       * @returns {Entry}
       * @instance
       */
  }, {
    key: "Entry",
    value: function Entry(uid) {
      var entry = new _entry["default"]();
      if (uid && typeof uid === 'string') {
        entry.entry_uid = uid;
      }
      return Utils.merge(entry, this);
    }

    /**
       * @method fetch
       * @memberOf ContentType
       * @description This method returns the complete information of a specific content type.
       * @example
       * let single_contenttype = Stack.ContentType(content_type_uid).fetch()
       *    single_contenttype
       *    .then(function(result) {
       *      // 'result' is a single contentType information.
       *     }).catch((error) => {
       *        console.log(error)
       *  });
       * @returns {promise}
       * @instance
       */
  }, {
    key: "fetch",
    value: function fetch(fetchOptions) {
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        plugins: this.plugins,
        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid,
        body: {
          _method: 'GET',
          environment: this.environment
        }
      };
      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);
      return (0, _request["default"])(this, options);
    }

    /**
       * @method Assets
       * @memberOf Stack
       * @param {String} uid - uid of the asset
       * @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.
       * @example
       * // Retrieves all assets
       * let data = Stack.Assets().Query().toJSON().find()
       *      data
       *      .then(function(result) {
       *          // All the asset with limit of 100
       *          // Use skip and limit functions to paginate
       *          // result will display all assets present in stack
       *      }, function(error) {
       *           // error function
       *      })
       *
       * @example
       * let data = Stack.Assets('asset_uid').toJSON().fetch()
       *      data
       *        .then(function(result) {
       *           // result is a single asset object of specified uid
       *      }, function(error) {
       *           // error function
       *      })
       *
       * @returns {Assets}
       * @instance
       */
  }, {
    key: "Assets",
    value: function Assets(uid) {
      this.type = 'asset';
      if (uid && typeof uid === 'string') {
        var asset = new _assets["default"]();
        asset.asset_uid = uid;
        return Utils.merge(asset, this);
      }
      return this;
    }

    /**
       * @method Query
       * @memberOf Stack
       * @description An initializer is responsible for creating Query object.Provides support for all search queries
       * @returns {Query}
       * @instance
       */
  }, {
    key: "Query",
    value: function Query() {
      // Taxonomy is a class that extends Query class and adds 4 more helper methods that use levels.
      // These 4 methods also work on contentType base url, hence Taxonomy instance is returned
      // Taxonomy instance is Regular Query instance + 4 additional methods (below, eq_below, above, eq_above)
      var query = this.type === 'contentType' ? new _taxonomy["default"]() : new _query["default"]();
      return Utils.merge(query, this);
    }

    /**
       * @method getLastActivities
       * @memberOf Stack
       * @description getLastActivities get all the ContentTypes whose last activity updated.
       * @example Stack.getLastActivities()
       * @example
       * let data = Stack.getLastActivities().toJSON().fetch()
       *      data
       *      .then(function(result) {
       *           // 'result' is list of contentTypes whose last activity updated.
       *      }, function(error) {
       *           // error function
       *      })
       * @returns {promise}
       * @instance
       */
  }, {
    key: "getLastActivities",
    value: function getLastActivities() {
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,
        body: {
          _method: 'GET',
          only_last_activity: true,
          environment: this.environment
        }
      };
      return (0, _request["default"])(this, this.fetchOptions);
    }

    /**
       * @method getContentTypes
       * @memberOf Stack
       * @param {String} param - Query on contentTypes
       * @description This method returns comprehensive information of all the content types of a particular stack in your account.
       * @example
       * let data = Stack.getContentTypes({"include_global_field_schema": true})
       *      data
       *      .then(function(result) {
       *           // 'result' is list of contentTypes.
       *      }, function(error) {
       *           // error function
       *      })
       * @returns {promise}
       * @instance
       */
  }, {
    key: "getContentTypes",
    value: function getContentTypes() {
      var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,
        body: {
          _method: 'GET',
          environment: this.environment
        }
      };
      if (param) {
        for (var key in param) {
          this.requestParams.body[key] = param[key];
        }
      }
      return (0, _request["default"])(this, this.fetchOptions);
    }

    /**
       * @method sync
       * @memberOf Stack
       * @description Syncs your Contentstack data with your app and ensures that the data is always up-to-date by providing delta updates
       * @param {object} params - params is an object that supports locale, start_date, content_type_uid, and type queries.
       * @example
       * Stack.sync({'init': true})        // For initializing sync
       * @example
       * Stack.sync({'init': true, 'locale': 'en-us'})     //For initializing sync with entries of a specific locale
       * @example
       * Stack.sync({'init': true, 'start_date': '2018-10-22'})    //For initializing sync with entries published after a specific date
       * @example
       * Stack.sync({'init': true, 'content_type_uid': 'session'})   //For initializing sync with entries of a specific content type
       * @example
       * Stack.sync({'init': true, 'type': 'entry_published'})   //Use the type parameter to get a specific type of content.Supports 'asset_published', 'entry_published', 'asset_unpublished', 'entry_unpublished', 'asset_deleted', 'entry_deleted', 'content_type_deleted'.
       * @example
       * Stack.sync({'pagination_token': '<page_tkn>'})    // For fetching the next batch of entries using pagination token
       * @example
       * Stack.sync({'sync_token': '<sync_tkn>'})    // For performing subsequent sync after initial sync
       * @returns {promise}
       * @instance
       */
  }, {
    key: "sync",
    value: function sync(params, fetchOptions) {
      if (params && _typeof(params) !== 'object') {
        throw new Error('Invalid parameters: params must be an object.');
      }
      this._query = {};
      if (params) {
        for (var key in params) {
          var value = params[key];
          if (params.hasOwnProperty(key)) {
            if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && !(value instanceof RegExp) && (_typeof(value) !== 'object' || value === null)) {
              throw new Error("Invalid parameter value for key \"".concat(key, "\": must be a string, number, object, boolean, or RegExp."));
            }
            this._query[key] = params[key];
          }
        }
      }
      this.requestParams = {
        method: 'POST',
        headers: Utils.mergeDeep({}, this.headers),
        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.sync,
        body: {
          _method: 'GET',
          query: this._query
        }
      };
      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);
      return Utils.sendRequest(Utils.mergeDeep({}, this), options);
    }

    /**
       * @method imageTransform
       * @memberOf Stack
       * @description Performs transformations on images of mentioned url based on transformation parameters
       * @param {String} url - Image url on which transformations need to be applied.
       * @param {String} params - Object with transformation parameters
       * @example
       * Stack.imageTransform(imageURL, {height: 100, width: 200, disable: "upscale"});
       * @example
       * Stack.imageTransform(imageURL, {crop: "150,100"});
       * @example
       * Stack.imageTransform(imageURL, {format: "png", crop: "150,100"});
       * @returns {string} [Image url with transformation parameters.]
       * @instance
       */
  }, {
    key: "imageTransform",
    value: function imageTransform(url, params) {
      if (url && typeof url === 'string' && _typeof(params) === 'object' && params.length === undefined) {
        var queryParams = [];
        for (var operation in params) {
          var encodedKey = encodeURIComponent(operation);
          var encodedValue = encodeURIComponent(params[operation]);
          queryParams.push(encodedKey + '=' + encodedValue);
        }
        url += url.indexOf('?') <= -1 ? '?' + queryParams.join('&') : '&' + queryParams.join('&');
      }
      return url;
    }
  }]);
}();

/***/ }),

/***/ 537:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var Utils = _interopRequireWildcard(__webpack_require__(925));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
/**
 * @class
  Assets
* @summary Creates an instance of `Assets`.
* @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.
* @param {String} uid - uid of asset you want to retrieve
* @example
* let data = Stack.Assets('asset_uid').toJSON().fetch()
*      data
*      .then(function(result) {
*           // result is a single asset object of specified uid
*      }, function(error) {
*           // error function
*      })
* @example
* // Retrieves all assets*
* let data = Stack.Assets().Query().toJSON().find()
*      data
*      .then(function(result) {
*          // All the asset with limit of 100
*          // Use skip and limit functions to paginate
*          // result will display all assets present in stack
*      }, function(error) {
*           // error function
*      })
* @returns {Assets}
* @instance
*/
var Assets = exports["default"] = /*#__PURE__*/function () {
  function Assets() {
    _classCallCheck(this, Assets);
    this._query = {};
    this.only = Utils.transform('only');
    return this;
  }

  /**
   * Converts your response into plain JavasScript object
   * @memberOf Assets
   * @example var Query = Stack.ContentType('blog').Query()
    Query
         .toJSON()
         .find()
         .then(function (result) {
             // 'result' is an object which content the data in json object form
          },function (error) {
             // error function
     })
   * @returns {Assets}
   * @instance
   */
  return _createClass(Assets, [{
    key: "toJSON",
    value: function toJSON() {
      this.tojson = true;
      return this;
    }

    /**
     * Includes query parameters in your queries.
     * @memberOf Assets
     * @example var data = Stack.Assets(assetUid).addParam('include_dimension', 'true').toJSON().fetch()
       *      data.then(function (result) {
       *          // 'result' is an object which content the data including count in json object form
       *       },function (error) {
       *          // error function
       *      })
       * @returns {Assets}
       * @instance
     */
  }, {
    key: "addParam",
    value: function addParam(key, value) {
      if (key && typeof key === 'string' && value && typeof value === 'string') {
        this._query[key] = value;
        return this;
      } else {
        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide a valid parameters.');
      }
    }

    /**
       * @method includeFallback
       * @memberOf Asset
       * @description Include the fallback locale publish content, if specified locale content is not publish.
       * @example stack.ContentType(contentType_uid).Assets(assetUid).includeFallback().fetch()
       * @returns {Asset}
       * @instance
       */
  }, {
    key: "includeFallback",
    value: function includeFallback() {
      this._query.include_fallback = true;
      return this;
    }

    /**
       * @method includeMetadata
       * @memberOf Asset
       * @description Include the metadata for getting metadata content for the asset.
       * @example stack.ContentType(contentType_uid).Assets(assetUid).includeMetadata().fetch()
       * @returns {Asset}
       * @instance
       */
  }, {
    key: "includeMetadata",
    value: function includeMetadata() {
      this._query.include_metadata = true;
      return this;
    }
    /**
     * Fetches a particular asset based on the provided asset UID.
     * @memberOf Assets
     * @example
     * Stack.Assets('assets_uid').toJSON().fetch()
     * @example
     * Stack.Assets('assets_uid').toJSON().fetch({
     *
     *      })
     * @returns {promise}
     * @instance
     */
  }, {
    key: "fetch",
    value: function fetch(fetchOptions) {
      if (this.asset_uid) {
        this.requestParams = {
          method: 'POST',
          headers: Utils.mergeDeep({}, this.headers),
          url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.assets + this.asset_uid,
          body: {
            _method: 'GET',
            query: this._query
          }
        };
        var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);
        return Utils.sendRequest(Utils.mergeDeep({}, this), options);
      } else {
        if (fetchOptions.debug) fetchOptions.logHandler('error', "Kindly provide an asset uid. e.g. .Assets('asset_uid')");
      }
    }
  }]);
}();

/***/ }),

/***/ 641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var cache = _interopRequireWildcard(__webpack_require__(94));
function _interopRequireWildcard(e, t) {
  if ("function" == typeof WeakMap) var r = new WeakMap(),
    n = new WeakMap();
  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = {
        __proto__: null,
        "default": e
      };
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return f;
    if (o = t ? n : r) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);
    return f;
  })(e, t);
}
var localStorage = {}; // eslint-disable-line

localStorage.get = function (key, callback) {
  try {
    callback(null, cache.get(key));
  } catch (e) {
    callback(e);
  }
};
localStorage.set = function (key, value, callback) {
  try {
    if (key && value) cache.set(key, value);
    callback();
  } catch (e) {
    callback(e);
  }
};
function clearValuesForKey(keyArray, append) {
  if (!append && keyArray && keyArray.length) keyArray.push('');
  var _key;
  var keys = cache.getKeys();
  var storage = cache.getStorage();
  if (!keyArray || !keyArray.length) {
    for (var i = 0, _i = keys.length; i < _i; i++) {
      delete storage[keys[i]];
    }
  } else {
    _key = keyArray.join('.');
    for (var _i2 = 0, _i3 = keys.length; _i2 < _i3; _i2++) {
      if (keys[_i2] && keys[_i2].indexOf(_key) === 0) delete storage[keys[_i2]];
    }
  }
}
localStorage.clearByContentType = function () {
  try {
    if (arguments.length === 2 || arguments.length === 3) {
      var args = Array.prototype.slice.call(arguments);
      var _callback = args.splice(-1, 1).pop();
      var valueArray = [];
      valueArray.push.apply(valueArray, args);
      clearValuesForKey(valueArray);
      _callback();
    }
  } catch (e) {
    callback(e);
  }
};
localStorage.clearByQuery = function (query, callback) {
  try {
    var keys = cache.getKeys();
    var storage = cache.getStorage();
    for (var i = 0, _i = keys.length; i < _i; i++) {
      if (keys[i] && ~keys[i].indexOf(query)) delete storage[keys[i]];
    }
    callback();
  } catch (e) {
    callback(e);
  }
};
localStorage.clearAll = function (callback) {
  try {
    clearValuesForKey();
    callback();
  } catch (e) {
    callback(e);
  }
};
var _default = exports["default"] = localStorage;

/***/ }),

/***/ 696:
/***/ ((module) => {

module.exports = require("localStorage");

/***/ }),

/***/ 697:
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var ContentstackRegion = {
  EU: 'eu',
  US: 'us',
  AU: 'au',
  AZURE_NA: 'azure-na',
  AZURE_EU: 'azure-eu',
  GCP_NA: 'gcp-na',
  GCP_EU: 'gcp-eu'
};
var _default = exports["default"] = ContentstackRegion;

/***/ }),

/***/ 722:
/***/ ((module) => {

module.exports = require("es6-promise");

/***/ }),

/***/ 880:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _localStorage = _interopRequireDefault(__webpack_require__(696));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
var _default = exports["default"] = _localStorage["default"];

/***/ }),

/***/ 925:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._type = _type;
exports.generateHash = generateHash;
exports.getHash = getHash;
exports.isBrowser = isBrowser;
exports.merge = merge;
exports.mergeDeep = mergeDeep;
exports.parseQueryFromParams = parseQueryFromParams;
exports.resultWrapper = resultWrapper;
exports.sendRequest = sendRequest;
exports.spreadResult = spreadResult;
exports.transform = transform;
var _request = _interopRequireDefault(__webpack_require__(185));
var _result = _interopRequireDefault(__webpack_require__(209));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return _regeneratorDefine2(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () {
    return this;
  }), _regeneratorDefine2(u, "toString", function () {
    return "[object Generator]";
  }), (_regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  })();
}
function _regeneratorDefine2(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) {
    if (r) i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n;else {
      var o = function o(r, n) {
        _regeneratorDefine2(e, r, function (e) {
          return this._invoke(r, n, e);
        });
      };
      o("next", 0), o("throw", 1), o("return", 2);
    }
  }, _regeneratorDefine2(e, r, n, t);
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _typeof2(o) {
  "@babel/helpers - typeof";

  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof2(o);
}
/**
 * @method addSpread
 * @description method to add the spread.
 */
(function addSpread() {
  if (Promise.prototype.spread) return;
  Promise.prototype.spread = function (fn, errFunc) {
    errFunc = errFunc || function (err) {};
    return this.then(function (args) {
      return fn.apply(fn, args);
    })["catch"](function (err) {
      errFunc(err);
    });
  };
})();
function transform(type) {
  return function () {
    this._query[type] = this._query[type] || {};
    switch (arguments.length) {
      case 1:
        if (Array.isArray(arguments[0]) || typeof arguments[0] === 'string') {
          var query = this._query[type].BASE || [];
          query = query.concat(arguments[0]);
          this._query[type].BASE = query;
          return this;
        } else {
          console.error('Kindly provide valid parameters');
        }
        break;
      case 2:
        if (typeof arguments[0] === 'string' && (Array.isArray(arguments[1]) || typeof arguments[1] === 'string')) {
          var _query2 = this._query[type][arguments[0]] || [];
          _query2 = _query2.concat(arguments[1]);
          this._query[type][arguments[0]] = _query2;
          return this;
        } else {
          console.error('Kindly provide valid parameters');
        }
        break;
      default:
        console.error('Kindly provide valid parameters');
    }
  };
}
function _type(val) {
  var _typeof;
  var __typeof = _typeof2(val);
  if (__typeof === 'object') {
    _typeof = __typeof;
    if (Array.isArray(val)) {
      __typeof = 'array';
    }
  } else {
    _typeof = __typeof;
  }
  return __typeof;
}

// merge two objects
function mergeDeep(destination, sourceVar) {
  var self = this;
  var _merge_recursive2 = function _merge_recursive(target, source) {
    for (var key in source) {
      if (self._type(source[key]) == 'object' && self._type(target[key]) == self._type(source[key])) {
        _merge_recursive2(target[key], source[key]);
      } else if (self._type(source[key]) == 'array' && self._type(target[key]) == self._type(source[key])) {
        target[key] = target[key].concat(source[key]);
      } else {
        target[key] = source[key];
      }
    }
  };
  _merge_recursive2(destination, sourceVar);
  return destination;
}

// merge two objects
function merge(target, source) {
  if (target && source) {
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}

// return true if process is running in browser else false
function isBrowser() {
  return typeof window !== 'undefined';
}

// return the query from the params
function parseQueryFromParams(queryObject, single, toJSON) {
  if (queryObject && queryObject.requestParams) {
    var _query = merge({}, queryObject.requestParams.body ? queryObject.requestParams.body.query || {} : {});
    if (_query.environment_uid) {
      delete _query.environment_uid;
      _query.environment = queryObject.environment;
    }
    _query.environment = queryObject.environment;
    return {
      content_type_uid: queryObject.content_type_uid,
      locale: _query.locale || 'en-us',
      query: _query,
      entry_uid: queryObject.entry_uid,
      asset_uid: queryObject.asset_uid,
      single: single || 'false',
      toJSON: toJSON || 'false',
      api_key: queryObject.requestParams.headers ? queryObject.requestParams.headers.api_key : ''
    };
  }
}

// return the hash value of the query
function getHash(query) {
  try {
    var hashValue = generateHash(JSON.stringify(query));
    var keyArray = [];
    keyArray.push(query.content_type_uid);
    keyArray.push(query.locale);
    if (query.entry_uid) keyArray.push(query.entry_uid);
    if (query.asset_uid) keyArray.push(query.asset_uid);
    keyArray.push(hashValue);
    return keyArray.join('.');
  } catch (e) {}
}

// return the hash value of the string
function generateHash(str) {
  var hash = 0;
  var i;
  var chr;
  var len;
  if (str.length === 0) return hash;
  for (i = 0, len = str.length; i < len; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash < -1 ? hash * -1 : hash;
}

// generate the Result object
function resultWrapper(result) {
  if (result && typeof result.entries !== 'undefined') {
    if (result.entries && result.entries.length) {
      for (var i = 0, _i = result.entries.length; i < _i; i++) {
        result.entries[i] = (0, _result["default"])(result.entries[i]);
      }
    } else {
      result.entries = [];
    }
  } else if (result && result.assets && typeof result.assets !== 'undefined') {
    if (result.assets && result.assets.length) {
      for (var j = 0, _j = result.assets.length; j < _j; j++) {
        result.assets[j] = (0, _result["default"])(result.assets[j]);
      }
    } else {
      result.assets = [];
    }
  } else if (result && typeof result.entry !== 'undefined') {
    result.entry = (0, _result["default"])(result.entry);
  } else if (result && typeof result.asset !== 'undefined') {
    result.asset = (0, _result["default"])(result.asset);
  } else if (result && typeof result.items !== 'undefined') {
    result.items = (0, _result["default"])(result.items).toJSON();
  }
  return result;
}

// spread the result object
function spreadResult(result) {
  var _results = [];
  if (result && Object.keys(result).length) {
    if (typeof result.entries !== 'undefined') {
      _results.push(result.entries);
      if (result.content_type) {
        _results.schema = result.content_type;
      }
    }
    if (typeof result.assets !== 'undefined') _results.push(result.assets);
    if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);
    if (typeof result.count !== 'undefined') _results.push(result.count);
    if (typeof result.entry !== 'undefined') {
      _results = result.entry;
      if (result.schema) {
        _results.schema = result.schema;
      }
      if (result.content_type) {
        _results.content_type = result.content_type;
      }
    }
    if (typeof result.asset !== 'undefined') _results = result.asset;
    if (typeof result.items !== 'undefined') _results.push(result);
  }
  return _results;
}
function sendRequest(queryObject, options) {
  var env_uid = queryObject.environment_uid;
  if (env_uid) {
    queryObject._query.environment_uid = env_uid;
  } else {
    if (queryObject._query) {
      queryObject._query.environment = queryObject.environment;
    } else {
      queryObject._query = {};
      queryObject._query.environment = queryObject.environment;
    }
  }
  var self = queryObject;
  var cachePolicy = typeof self.queryCachePolicy !== 'undefined' ? self.queryCachePolicy : self.cachePolicy;
  var tojson = typeof self.tojson !== 'undefined' ? self.tojson : false;
  var isSingle = !!(self.entry_uid || self.singleEntry || self.asset_uid);
  var hashQuery = getHash(parseQueryFromParams(self, isSingle, tojson));

  /**
    for new api v3
    */
  if (queryObject && queryObject.requestParams && queryObject.requestParams.body && queryObject.requestParams.body.query) {
    var cloneQueryObj = JSON.parse(JSON.stringify(queryObject.requestParams.body.query));
    if (_typeof2(cloneQueryObj) !== 'object') {
      cloneQueryObj = JSON.parse(cloneQueryObj);
    }
    delete queryObject.requestParams.body.query;
    queryObject.requestParams.body = merge(queryObject.requestParams.body, cloneQueryObj);
    if (queryObject.live_preview && queryObject.live_preview.enable === true && queryObject.live_preview.live_preview && queryObject.live_preview.live_preview !== 'init') {
      queryObject.requestParams.body = merge(queryObject.requestParams.body, {
        live_preview: queryObject.live_preview.live_preview || 'init'
      });
      cachePolicy = 2; // network else cache
      if (queryObject.requestParams.body.environment) {
        delete queryObject.requestParams.body.environment;
      }
      if (queryObject.requestParams.headers.access_token) {
        delete queryObject.requestParams.headers.access_token;
      }
      delete queryObject.requestParams.headers.authorization;
      delete queryObject.requestParams.headers.preview_token;
      if (queryObject.live_preview.preview_token) {
        queryObject.requestParams.headers.preview_token = queryObject.live_preview.preview_token;
        queryObject.requestParams.headers.live_preview = queryObject.live_preview.live_preview;
      } else if (queryObject.live_preview.management_token) {
        queryObject.requestParams.headers.authorization = queryObject.live_preview.management_token;
      }
    }
  }
  var getCacheCallback = function getCacheCallback(resolve, reject) {
    return function (err, entries) {
      try {
        if (err) {
          return reject(err); // Propagate the error to the parent promise
        }
        if (!tojson) entries = resultWrapper(entries);
        resolve(spreadResult(entries)); // Propagate the result to the parent promise
      } catch (e) {
        reject(e); // Handle any synchronous errors
      }
    };
  };
  var callback = function callback(continueFlag, resolve, reject) {
    if (continueFlag) {
      (0, _request["default"])(queryObject, options).then(function (data) {
        try {
          self.entry_uid = self.asset_uid = self.tojson = self.queryCachePolicy = undefined;
          var entries = {};
          var syncstack = {};
          if (queryObject.singleEntry) {
            queryObject.singleEntry = false;
            if (data.schema) entries.schema = data.schema;
            if (data.content_type) {
              entries.content_type = data.content_type;
              delete entries.schema;
            }
            if (data.entries && data.entries.length) {
              entries.entry = data.entries[0];
            } else if (data.assets && data.assets.length) {
              entries.assets = data.assets[0];
            } else {
              if (cachePolicy === 2 && self.provider !== null) {
                self.provider.get(hashQuery, function (err, _data) {
                  if (err || !_data || _data.entries.length === 0 && _data.assets.length === 0) {
                    return reject({
                      error_code: 141,
                      error_message: 'The requested entry doesn\'t exist.'
                    });
                  }
                  getCacheCallback(resolve, reject)(err, _data);
                });
                return;
              } else {
                return reject({
                  error_code: 141,
                  error_message: 'The requested entry doesn\'t exist.'
                });
              }
            }
          } else if (data.items) {
            syncstack = {
              items: data.items,
              pagination_token: data.pagination_token,
              sync_token: data.sync_token,
              total_count: data.total_count
            };
          } else {
            entries = data;
          }
          if (cachePolicy !== -1 && self.provider !== null) {
            self.provider.set(hashQuery, entries, function (err) {
              try {
                if (err) reject(err);
                if (!tojson) entries = resultWrapper(entries);
                return resolve(spreadResult(entries));
              } catch (e) {
                return reject(e);
              }
            });
            return resolve(spreadResult(entries));
          }
          if (Object.keys(syncstack).length) {
            return resolve(syncstack);
          }
          if (!tojson) {
            entries = resultWrapper(entries);
          }
          return resolve(spreadResult(entries));
        } catch (e) {
          return reject({
            message: e.message
          });
        }
      })["catch"](function (error) {
        if (error) {
          reject(error);
        } else if (cachePolicy === 2 && self.provider !== null) {
          self.provider.get(hashQuery, getCacheCallback(resolve, reject));
        }
      });
    }
  };
  switch (cachePolicy) {
    case 1:
      return new Promise(/*#__PURE__*/function () {
        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(resolve, reject) {
          return _regenerator().w(function (_context2) {
            while (1) switch (_context2.n) {
              case 0:
                if (!(self.provider !== null)) {
                  _context2.n = 2;
                  break;
                }
                _context2.n = 1;
                return self.provider.get(hashQuery, /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(err, _data) {
                    var _t;
                    return _regenerator().w(function (_context) {
                      while (1) switch (_context.p = _context.n) {
                        case 0:
                          _context.p = 0;
                          if (!(err || !_data)) {
                            _context.n = 1;
                            break;
                          }
                          callback(true, resolve, reject);
                          _context.n = 2;
                          break;
                        case 1:
                          if (!tojson) {
                            _data = resultWrapper(_data);
                          }
                          return _context.a(2, resolve(spreadResult(_data)));
                        case 2:
                          _context.n = 4;
                          break;
                        case 3:
                          _context.p = 3;
                          _t = _context.v;
                          return _context.a(2, reject(_t));
                        case 4:
                          return _context.a(2);
                      }
                    }, _callee, null, [[0, 3]]);
                  }));
                  return function (_x3, _x4) {
                    return _ref2.apply(this, arguments);
                  };
                }());
              case 1:
                _context2.n = 3;
                break;
              case 2:
                callback(true, resolve, reject);
              case 3:
                return _context2.a(2);
            }
          }, _callee2);
        }));
        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    case 2:
    case 0:
    case undefined:
    case -1:
      return new Promise(function (resolve, reject) {
        callback(true, resolve, reject);
      });
  }
  if (cachePolicy === 3) {
    var promise = new Promise(function (resolve, reject) {
      if (self.provider !== null) {
        self.provider.get(hashQuery, function (err, _data) {
          try {
            if (err || !_data) {
              reject(err);
            } else {
              if (!tojson) {
                _data = resultWrapper(_data);
              }
              resolve(spreadResult(_data));
            }
          } catch (e) {
            reject(e);
          }
        });
      }
    });
    return promise.then(function () {
      return new Promise(function (resolve, reject) {
        callback(true, resolve, reject);
      });
    })["catch"](function (error) {
      return new Promise(function (resolve, reject) {
        callback(true, resolve, reject);
      });
    });
  }
}

/***/ }),

/***/ 940:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _es6Promise = _interopRequireDefault(__webpack_require__(722));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
_es6Promise["default"].polyfill();
var _default = exports["default"] = fetch; // fetch API available in Node.js 18 and later

/***/ }),

/***/ 949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _stack = _interopRequireDefault(__webpack_require__(348));
var _index = _interopRequireDefault(__webpack_require__(285));
var _contentstackregion = _interopRequireDefault(__webpack_require__(697));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0,
        F = function F() {};
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: !0
          } : {
            done: !1,
            value: r[_n++]
          };
        },
        e: function e(r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = !0,
    u = !1;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r = t.next();
      return a = r.done, r;
    },
    e: function e(r) {
      u = !0, o = r;
    },
    f: function f() {
      try {
        a || null == t["return"] || t["return"]();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
/**
 * @class Contentstack
 * @description Creates an instance of `Contentstack`.
 * @instance
 */
var Contentstack = /*#__PURE__*/function () {
  function Contentstack() {
    _classCallCheck(this, Contentstack);
    /**
    * @memberOf Contentstack
    * @description CachePolicy contains different cache policies constants.
    * @example
    * Contentstack.CachePolicy.IGNORE_CACHE
    * Contentstack.CachePolicy.ONLY_NETWORK
    * Contentstack.CachePolicy.CACHE_ELSE_NETWORK
    * Contentstack.CachePolicy.NETWORK_ELSE_CACHE
    * Contentstack.CachePolicy.CACHE_THEN_NETWORK
    */
    this.CachePolicy = _index["default"].policies;
    this.Region = _contentstackregion["default"];
    this.Utils = __webpack_require__(253);
  }

  /**
  * @memberOf Contentstack
  */
  return _createClass(Contentstack, [{
    key: "Stack",
    value: function Stack() {
      for (var _len = arguments.length, stack_arguments = new Array(_len), _key = 0; _key < _len; _key++) {
        stack_arguments[_key] = arguments[_key];
      }
      return _construct(_stack["default"], stack_arguments);
    }
  }, {
    key: "updateAssetURL",
    value: function updateAssetURL(entry) {
      // check if entry consist of _embedded_items object
      if (entry._embedded_items == undefined) {
        throw new Error('_embedded_items not present in entry. Call includeEmbeddedItems() before fetching entry.');
      }

      // Iterate through each object in _embedded_items and update the asset link
      var _loop = function _loop(key) {
        var embedded_item = entry._embedded_items[key];
        if (Array.isArray(embedded_item)) {
          embedded_item.forEach(function (item) {
            if (item._content_type_uid == 'sys_assets' && item.filename) {
              var correspondingAsset;
              var _x = function x(children) {
                for (var i = 0; i < children.length; i++) {
                  if (children[i].children && children[i].children.length) {
                    _x(children[i].children);
                  }
                  if (children[i].attrs && children[i].attrs['asset-uid'] === item.uid) {
                    correspondingAsset = children[i].attrs;
                    return;
                  }
                }
              };
              var _entry = _objectSpread({}, entry);
              var keys = key.split('.');
              var unsafeKeys = new Set(['__proto__', 'constructor', 'prototype']);
              var _iterator = _createForOfIteratorHelper(keys),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var k = _step.value;
                  // Ensure key is safe before accessing it
                  if (unsafeKeys.has(k)) continue;
                  if (_entry && _typeof(_entry) === 'object' && _entry !== null && Object.prototype.hasOwnProperty.call(_entry, k)) {
                    var newEntry = _entry[k];
                    if (_typeof(newEntry) === 'object' && newEntry !== null) {
                      _entry = newEntry;
                    }
                  } else if (Array.isArray(_entry)) {
                    var _iterator2 = _createForOfIteratorHelper(_entry),
                      _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var block = _step2.value;
                        if (block && _typeof(block) === 'object' && Object.prototype.hasOwnProperty.call(block, k)) {
                          _entry = block[k];
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              if (_entry.children) _x(_entry.children);
              if (correspondingAsset) {
                correspondingAsset.href = item.url;
              }
            }
          });
        }
      };
      for (var key in entry._embedded_items) {
        _loop(key);
      }
    }
  }]);
}();
module.exports = new Contentstack();

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(949);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;